(define (numer x) (car x))
(define (denom x) (cdr x))
    (define (gcd a b)
        (if (= b 0) a
            (gcd b (remainder a b))))
(define (make-rat n d)
    (let ((g (gcd n d)))
         (cons (/ n g) (/ d g))))
(define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))

(define (add-rat x y)
    (make-rat (+ (* (numer x)
                    (denom y))
                 (* (numer y)
                    (denom x)))
              (* (denom x)
                 (denom y))))
(define (sub-rat x y)
    (make-rat (- (* (numer x)
                    (denom y))
                 (* (numer y)
                    (denom x)))
              (* (denom x)
                 (denom y))))
(define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
(define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

(define num1 (make-rat 2 2))
(define num2 (make-rat 1 2))
;2.1
(define (make-rat-new n d)
    (define (negate x) (- 0 x))
    (define (abs x) (if (> x 0) x (negate x)))
    (let ((g (gcd n d)))
    (cond ((or (and (> n 0) (< d 0)
               (and (< n 0) (> d 0))))
           (cons (negate (abs((/ n g))))
                 (abs (/ d g))))
          (else
           (cons (/ n g) (/ d g))))))
;2.2
(define (point x y) (cons x y))
(define (x-point x) (car x))
(define (y-point x) (cdr x))
(define (make-segment p1 p2) (cons p1 p2))
(define (start-segment x) (car x))
(define (end-segment x) (cdr x))
(define (midpoint-segment a)
    (define (mid x1 x2) (/ (+ x1 x2) 2.0))
    (let ((s (start-segment a))
          (e (end-segment a)))
         (point (mid (x-point s) (x-point e))
                (mid (y-point s) (y-point e)))))
(define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
;2.3 可以用两个点或者一条线段(对角线)来表示一个矩形
(define (abs x) (if (> x 0) x (- 0 x)))
(define (area r)
    (let ((p1 (get-point1 r))
          (p2 (get-point2 r)))
         (* (abs (- (x-point p1) (x-point p2)))
            (abs (- (y-point p1) (y-point p2))))))
(define (perimeter r)
    (let ((p1 (get-point1 r))
          (p2 (get-point2 r)))
         (* 2
            (+ (abs (- (x-point p1) (x-point p2)))
               (abs (- (y-point p1) (y-point p2)))))))
(define p1 (point 0 0))
(define p2 (point 3 4))
;2 points:
(define (rectangle p1 p2) (cons p1 p2))
(define (get-point1 r) (car r))
(define (get-point2 r) (cdr r))
(define r1 (rectangle p1 p2))
;1 segment
(define (rectangle-s s) s)
(define (get-point1-s r) (start-segment r))
(define (get-point2-s r) (end-segment r))
(define r2 (rectangle-s (make-segment p1 p2)))
;2.4
(define (cons-24 x y)
    (lambda (m) (m x y)))
(define (car-24 z)
    (z (lambda (x y) x)))
(define (cdr-24 z)
    (z (lambda (x y) y)))
;2.5
(define (sqrt a b)
    (define (square x) (* x x))
    (cond ((= b 0) 1)
          ((= b 1) a)
          ((= 1 (remainder b 2))
            (* a (sqrt a (- b 1))))
          (else (square (sqrt a (/ b 2))))))
(define (decomp a b)
    (if (and (or (= a b) (> a b)) (= 0 (remainder a b)))
        (+ 1 (decomp (/ a b) b))
        0))
(define (cons-25 a b)
    (* (sqrt 2 a)
       (sqrt 3 b)))
(define (car-25 c) (decomp c 2))
(define (cdr-25 c) (decomp c 3))
;2.6
(define zero (lambda (f) (lambda (x) x)))
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
(define (add a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
;
;
;
;2.7
(define (make-interval a b) (cons a b))
(define (upper-bound i) (cdr i))
(define (lower-bound i) (car i))
(define (print-interval i)
    (newline)
    (display "[")
    (display (lower-bound i))
    (display ",")
    (display (upper-bound i))
    (display "]"))
;2.8
(define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))
(define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))
;2.9 大概没得代码
;2.10
(define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))
(define (div-interval x y)
    (if (or (= 0 (upper-bound y)) (= 0 (lower-bound y)))
        (error "error" y)
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
;2.11 lm问题
;2.12
(define (make-center-width c w)
    (make-inaterval (- c w) (+ c w)))
(define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
(define (make-center-percent c p)
    (let ((w (* c p)))
        (make-interval (- c w) (+ c w))))
(define (percent i)
    (let ((c (center i)))
         (if (= 0 c)
             (error "error" i)
             (abs (/ (width i) c)))))
;2.13
(define (mul-percent i1 i2)
    (let ((x (/ (* (lower-bound i1) (lower-bound i2))
                   (upper-bound i1) (upper-bound i2))))
         (/ (- 1 x)
            (+ 1 x))))
;2.14
(define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))
(define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
        (div-interval one
                      (add-interval (div-interval one r1)
                                    (div-interval one r2)))))

(define i1 (make-interval 9 11))
(define i2 (make-interval 19 21))
;2.15
;不对，不能说一个比另一个好。
;2.16
;区间运算中，加法减法、乘法除法不互为逆运算，而且区间四则运算的幺元和零元也没有被定义
;有理数四则运算的代数变化不适用于区间运算，也就是说这两个代数表达式本来就不相等。