(define (make-machine register-names ops controller-text)
    (let ((machine (make-new-machine)))
        (for-each (lambda (register-name)
                    ((machine 'allocate-register) register-name))
                  register-names)
        ((machine 'install-operations) ops)
        (let ((inst-label (assemble controller-text machine)))
            ((machine 'install-instruction-sequence) (car inst-label))
            ((machine 'install-labels) (cdr inst-label))
            machine)))
;register                       
(define (make-register name)
    (let ((contents '*unassigned*)
          (trace #f));;;
        (define (set-register value)
            (if trace
                (begin (newline)
                       (display name)
                       (display ":")
                       (display contents)
                       (display " -> ")
                       (display value)
                       (set! contents value))
                (set! contents value)))
        (define (dispatch message)
            (cond ((eq? message 'get) contents)
                  ((eq? message 'set) set-register)
                  ((eq? message 'trace-on) (set! trace #t))
                  ((eq? message 'trace-off) (set! trace #f))
                  (else
                    (error "register" "unknown request" message))))
        dispatch))
(define (get-contents register) (register 'get))
(define (set-contents! register value) ((register 'set) value))
(define (set-register-trace! machine reg-name on-off);;;
    ((machine 'reg-trace) reg-name on-off))
;stack
(define (make-stack)
    (let ((s '())
          (number-pushes 0)
          (max-depth 0)
          (current-depth 0))
        (define (push x)
            (set! s (cons x s))
            (set! number-pushes (+ 1 number-pushes))
            (set! current-depth (+ 1 current-depth))
            (set! max-depth (max current-depth max-depth)))
        (define (pop)
            (if (null? s)
                (error "pop" "Empty stack" x))
                (let ((top (car s)))
                    (set! s (cdr s))
                    (set! current-depth (- current-depth 1))
                    top))
        (define (initialize)
            (set! s '())
            (set! number-pushes 0)
            (set! current-depth 0)
            (set! max-depth 0)
            'done)
        (define (print-statistics)
            (newline)
            (display (list 'total-pushes '= number-pushes
                           'maximum-depth '= max-depth)))
        (define (dispatch message)
            (cond ((eq? message 'push) push)
                  ((eq? message 'pop) (pop))
                  ((eq? message 'initialize) (initialize))
                  ((eq? message 'print-statistics) (print-statistics))
                  (else (error "stack" "unknown request" message))))
        dispatch))
(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))
;initial-machine
(define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence '())
          (labels '()))
        (let ((the-ops
                (list (list 'initialize-stack
                            (lambda () (stack 'initialize)))
                      (list 'print-stack-statistics
                            (lambda () (stack 'print-statistics)))))
              (register-table
                (list (list 'pc pc)
                      (list 'flag flag)))
              (bp-table '())
              (inst-counter 0)
              (trace #f))
            (define (allocate-register name)
                (if (assoc name register-table)
                    (error "allocate-register" "Multiply define register:" name)
                    (set! register-table
                          (cons (list name (make-register name))
                                register-table)))
                'register-allocated)
            (define (lookup-register name)
                (let ((val (assoc name register-table)))
                    (if val
                        (cadr val)
                        (error "lookup-register" "Unknown register" name))))
            (define (lookup-label name)
                (let ((label (assoc name labels)))
                    (if label
                        (cdr label)
                        (error "lookup-label" "Unknown label" label))))
            (define (execute)
                (let ((insts (get-contents pc)))
                    (if (null? insts)
                        'done
                        (if (breakpoint? (car insts))
                            (begin (display "breakpoint: ")
                                   (display (breakpoint-label (car insts)))
                                   (display "  ")
                                   (display (breakpoint-diff (car insts)))
                                   (advance-pc pc))
                            (begin ((instruction-execution-proc (car insts)))
                                   (set! inst-counter (+ 1 inst-counter))
                                   (if trace
                                       (begin (newline)
                                              (display (instruction-text (car insts)))))
                                   (execute))))))
            (define (set-breakpoint label-name n)
                (let ((label (lookup-label label-name)))
                    (define (aim-inst insts diff)
                        (cond ((<= diff 0) (error "set-breakpoint" "n can't be less than 1" label))
                              ((null? insts)
                                (error "set-breakpoint" "breakpoint can't be set since the porc finished" label))
                              ((= diff 1)
                                (let ((temp (car insts))
                                     (bp (list 'breakpoint label-name n)))
                                    (set-car! insts bp)
                                    (set-cdr! insts (cons temp (cdr insts)))
                                    (set! bp-table (cons (cons bp insts) bp-table))))
                              (else
                                (aim-inst (cdr insts) (- diff 1)))))
                    (aim-inst label n)))
            (define (delete-one-breakpoint bp)
                (let ((inst (cdr (car bp))))
                    (set-car! inst (cadr inst))
                    (set-cdr! inst (cddr inst)))
                (if (null? (cdr bp))
                    (set! bp '())
                    (begin (set-car! bp (cadr bp))
                           (set-cdr! bp (cddr bp))))) 
            (define (cancel-breakpoint label-name n)
                (define (lookup-breakpoint breakpoint table)
                    (cond ((null? table) (error "lookup breakpoint" "not such breakpoint" label-name))
                          ((equal? breakpoint (car (car table))) table)
                          (else (lookup-breakpoint breakpoint (cdr table)))))
                (let ((bp (lookup-breakpoint (list 'breakpoint label-name n) bp-table)))
                    (delete-one-breakpoint bp)))
            (define (cancel-all-breakpoint)
                (if (not (null? bp-table))
                    (begin (delte-one-breakpoint bp-table)
                           (cancel-all-breakpoint))))
            (define (dispatch message)
                (cond ((eq? message 'start)
                       (set-contents! pc the-instruction-sequence)
                       (execute))
                      ((eq? message 'proceed-machine) (execute))
                      ((eq? message 'install-instruction-sequence)
                       (lambda (seq) (set! the-instruction-sequence seq)))
                      ((eq? message 'install-labels);;;
                       (lambda (lab) (set! labels lab)))
                      ((eq? message 'get-label) lookup-label)
                      ((eq? message 'allocate-register) allocate-register)
                      ((eq? message 'get-register) lookup-register)
                      ((eq? message 'install-operations)
                       (lambda (ops) (set! the-ops (append the-ops ops))))
                      ((eq? message 'stack) stack)
                      ((eq? message 'operations) the-ops)
                      ((eq? message 'trace-on) (set! trace #t));;;
                      ((eq? message 'trace-off) (set! trace #f));;;
                      ((eq? message 'inst-number);;;
                       (let ((temp inst-counter))
                        (set! inst-counter 0)
                        temp))
                      ((eq? message 'reg-trace);;;
                       (lambda (reg-name switch) ((lookup-register reg-name) switch)))
                      ((eq? message 'set-breakpoint) set-breakpoint)
                      ((eq? message 'cancel-breakpoint) cancel-breakpoint)
                      ((eq? message 'cancel-all-breakpoint) (cancel-all-breakpoint))
                      (else (error "machine" "Unknown request" message))))
            dispatch)))
(define (start machine) (machine 'start))
(define (get-register machine reg-name) ((machine 'get-register) reg-name))
(define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name) value)
    'done)
;
(define (assemble controller-text machine)
    (extract-labels controller-text
                    (lambda (insts labels)
                        (update-insts! insts labels machine)
                        (cons insts labels))))
(define (extract-labels text receive)
    (if (null? text)
        (receive '() '())
        (extract-labels (cdr text)
                        (lambda (insts labels)
                            (let ((next-inst (car text)))
                                (if (symbol? next-inst)
                                    (receive insts
                                             (cons (make-label-entry next-inst
                                                                     insts)
                                                   labels))
                                    (receive (cons (make-instruction next-inst)
                                                   insts)
                                             labels)))))))
(define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
          (flag (get-register machine 'flag))
          (stack (machine 'stack))
          (ops (machine 'operations)))
        (for-each
            (lambda (inst)
                (set-instruction-execution-proc!
                    inst
                    (make-execution-procedure
                        (instruction-text inst) labels machine
                        pc flag stack ops)))
            insts)))
(define (make-instruction text)
    (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc)
    (set-cdr! inst proc))
(define (make-label-entry label-name insts) (cons label-name insts))
(define (lookup-label labels label-name)
    (let ((val (assoc label-name labels)))
        (if val
            (cdr val)
            (error "assemble" "Undefined label" label-name))))
(define (make-execution-procedure inst labels machine pc flag stack ops)
    (cond ((eq? (car inst) 'assign)
           (make-assign inst machine labels ops pc))
          ((eq? (car inst) 'test)
           (make-test inst machine labels ops flag pc))
          ((eq? (car inst) 'branch)
           (make-branch inst machine labels flag pc))
          ((eq? (car inst) 'goto)
           (make-goto inst machine labels pc))
          ((eq? (car inst) 'save)
           (make-save inst machine stack pc))
          ((eq? (car inst) 'restore)
           (make-restore inst machine stack pc))
          ((eq? (car inst) 'perform)
           (make-perform inst machine labels ops pc))
          (else (error "ASSEMBLE" "Unknown instruction type" inst))))
;assign
(define (make-assign inst machine labels operations pc)
    (let ((target
            (get-register machine (assign-reg-name inst)))
          (value-exp (assign-value-exp inst)))
        (let ((value-proc
                (if (operation-exp? value-exp)
                    (make-operation-exp
                        value-exp machine labels operations)
                    (make-primitive-exp
                        (car value-exp) machine labels))))
            (lambda ()
                (set-contents! target (value-proc))
                (advance-pc pc)))))
(define (assign-reg-name assign-instruction) (cadr assign-instruction))
(define (assign-value-exp assign-instruction) (cddr assign-instruction))
(define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))
;跳转
(define (make-test inst machine labels operations flag pc)
    (let ((condition (test-condition inst)))
        (if (operation-exp? condition)
            (let ((condition-proc
                    (make-operation-exp
                        condition machine labels operations)))
                (lambda ()
                    (set-contents! flag (condition-proc))
                    (advance-pc pc)))
            (error "ASSEMBLE" "Bad test" inst))))
(define (test-condition test-instruction)
    (cdr test-instruction))
;为什么branch不能用reg地址而goto可以
(define (make-branch inst machine labels flag pc)
    (let ((dest (branch-dest inst)))
        (if (label-exp? dest)
            (let ((insts
                    (lookup-label labels (label-exp-label dest))))
                (lambda ()
                    (if (get-contents flag)
                        (set-contents! pc insts)
                        (advance-pc pc))))
            (error "ASSEMBLE" "Bad branch" inst))))
(define (branch-dest branch-instruction) (cadr branch-instruction))
(define (make-goto inst machine labels pc)
    (let ((dest (goto-dest inst)))
        (cond ((label-exp? dest)
                (let ((insts
                        (lookup-label labels (label-exp-label dest))))
                    (lambda () (set-contents! pc insts))))
              ((register-exp? dest)
                (let ((reg
                        (get-register machine (register-exp-reg dest))))
                    (lambda () (set-contents! pc (get-contents reg)))))
              (else
                (error "ASSEMBLE" "Bad GOTO" isnt)))))
(define (goto-dest goto-instruction) (cadr goto-instruction))
;stak and perform
(define (make-save inst machine stack pc)
    (let ((reg (get-register machine (stack-inst-reg-name inst))))
        (lambda ()
            (push stack (get-contents reg))
            (advance-pc pc))))
(define (make-restore inst machine stack pc)
    (let ((reg (get-register machine (stack-inst-reg-name inst))))
        (lambda ()
            (set-contents! reg (pop stack))
            (advance-pc pc))))
(define (stack-inst-reg-name stack-instruction)
    (cadr stack-instruction))
(define (make-preform inst machine labels operations pc)
    (let ((action (preform-action inst)))
        (if (operation-exp? action)
            (let ((action-proc
                    (make-operation-exp
                        action machine labels operations)))
                (lambda ()
                    (action-proc)
                    (advance-pc pc)))
            (error "ASSEMBLE" "bad perform" inst))))
(define (preform-action) (cdr inst))
;构造执行
(define (make-primitive-exp exp machine labels)
    (cond ((constant-exp? exp)
            (let ((c (constant-exp-value exp)))
                (lambda () c)))
          ((label-exp? exp)
            (let ((insts (lookup-labels labels (label-exp-label exp))))
                (lambda () insts)))
          ((register-exp? exp)
            (let ((reg (get-register machine (register-exp-reg exp))))
                (lambda () (get-contents reg))))
          (else
            (error "ASSEMBLE" "Unknown expression typr" exp))))
(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))
;
(define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp) operations))
          (aprocs
            (map (lambda (e)
                    (make-primitive-exp e machine labels))
                 (operation-exp-operands exp))))
        (lambda ()
            (apply op (map (lambda (p) (p)) aprocs)))))
(define (operation-exp? exp)
    (and (pair? exp)
         (tagged-list? (car exp) 'op)))
(define (operation-exp-op exp) (cadar exp))
(define (operation-exp-operands exp) (cdr exp))
(define (lookup-prim symbol operations)
    (let ((val (assoc symbol operations)))
        (if val
            (cadr val)
            (error "ASSEMBLE" "Unknown operation" symbol))))
(define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))
;5.15
;5.16
;5.18
;5.19
(define (breakpoint? exp) (tagged-list? exp 'breakpoint))
(define (breakpoint-label bp) (cadr bp))
(define (breakpoint-diff bp) (caddr bp))
(define (get-machine-label machine label-name)
    ((machine 'get-label) label-name))
(define (set-machine-breakpoint machine label-name n)
    ((machine 'set-breakpoint) label-name n))
(define (cancel-machine-breakpoint machine label-name n)
    ((machine 'cancel-breakpoint) label-name n))
(define (cancel-machine-all-breakpoint machine)
    (machine 'cancel-all-breakpoint))
;
;
;test
 (define fact-machine 
   (make-machine 
    '(c p n) 
    (list (list '* *) (list '+ +) (list '> >)) 
    '((assign c (const 1)) 
      (assign p (const 1)) 
      test-n 
      (test (op >) (reg c) (reg n)) 
      (branch (label fact-done)) 
      (assign p (op *) (reg c) (reg p)) 
      (assign c (op +) (reg c) (const 1)) 
      (goto (label test-n)) 
      fact-done))) 
 (fact-machine 'trace-off)
;  (set-register-trace! fact-machine 'c 'trace-on)
;  (set-register-trace! fact-machine 'p 'trace-on)
 (set-register-contents! fact-machine 'n 5)
 (set-machine-breakpoint fact-machine 'test-n 3)
 (start fact-machine) 
; (fact-machine 'proceed-machine)
; (get-register-contents fact-machine 'p)
; (cancel-machine-breakpoint fact-machine 'test-n 3)

;5.21
;a)
(define count-leaves-machine
    '(t val temp continue)
    (list (list '+ +) (list 'null? null?) (list 'pair? pair?)
          (list 'car car) (list 'cdr cdr))
    '((assign val (const 0))
      (assign continue (label count-done))
    count-loop
      (test (op null?) (reg t))
      (branch (label zero))
      (test (op pair?) (reg t))
      (branch (label left-tree))
      (assign val (const 1))
      (goto (reg continue))
    left-tree
      (save t)
      (save continue)
      (assign t (op car) (reg t))
      (assign continue (label right-tree))
      (goto (label count-loop))
    right-tree
      (restore continue)
      (restore t)
      (save continue)
      (save val)
      (assign continue (label after))
      (assign t (op cdr) (reg t))
      (goto (label count-loop))
    after
      (assign temp (reg val))
      (restore val)
      (restore continue)
      (assign val (op +) (reg val) (reg temp))
      (goto (reg continue))
    zero
      (assign val (const 0))
      (goto (reg continue))
    count-done))
;b)不想写了


