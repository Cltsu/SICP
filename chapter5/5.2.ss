;5.8
(define (extract-labels text receive)
    (if (null? text)
        (receive '() '())
        (extract-labels (cdr text)
                        (lambda (insts labels)
                            (let ((next-inst (car text)))
                                (if (symbol? next-inst)
                                    (if (assoc next-inst labels)
                                        (error "label" "duplicated label" next-inst))
                                        (receive insts
                                                 (cons (make-label-entry next-inst
                                                                     insts)
                                                      labels))
                                    (receive (cons (make-instruction next-inst)
                                                   insts)
                                             labels)))))))
;5.9
(define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp) operations))
          (aprocs
            (map (lambda (e)
                    (if (label-exp? e)
                        (error "ASSEMBLE" "label pa" e)
                        (make-primitive-exp e machine labels)))
                 (operation-exp-operands exp))))
        (lambda ()
            (apply op (map (lambda (p) (p)) aprocs)))))
;5.10
;不是很明白题目什么意思,不过感觉不是一道有意思的题
;5.11
;a)灵活性更高，但是也更容易出bug
;b)
(define (make-save inst machine stack pc)
    (let ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
        (lambda ()
            (push stack (cons reg-name (get-contents reg))
            (advance-pc pc))))
(define (make-restore inst machine stack pc)
    (let ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
        (lambda ()
            (let ((pop-reg (pop stack)))
                (if (tagged-list? pop-reg reg-name)
                    (begin (set-contents! reg (cdr pop-reg))
                           (advance-pc pc))
                    (error "ASSEMBLE" "not correspond reg" reg-name))))))
;c)
;为每个reg创建一个stack，在make-machine装载reg的时候还需要扩充stack，这里只实现了flag和pc
(define (make-stack)
    (let ((s '()))
        (define (push x)
            (let ((reg-stack (assoc s (stack-reg-name x))))
                (if reg-stack
                    (set-cdr! reg-stack (cons (stack-reg-content x) (cdr reg-stack)))
                    (error "ASSEMBLE" "not reg" (stack-reg-name x)))))
        (define (pop x)
            (let ((reg-name (stack-reg-name x))
                  (reg-stack (assoc s reg-name)))
                (if reg-stack
                    (if (null? (cdr reg-stack))
                        (error "pop" "Empty stack" reg-name)
                        (let ((top (cadr reg-stack)))
                            (set-cdr! reg-stack (cddr reg-stack))
                            top))
                    (error "ASSEMBLE" "not such reg" reg-name))))
        (define (initialize)
            (set! s (list (cons 'flag '()) (cons 'pc '()))
            'done)
        (define (dispatch message)
            (cond ((eq? message 'push) push)
                  ((eq? message 'pop) (pop))
                  ((eq? message 'initialize) (initialize))
                  (else (error "stack" "unknown request" message))))
        dispatch))
;在传reg的值的时候连同reg的名字一起传过去
(define (make-save inst machine stack pc)
    (let ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
        (lambda ()
            (push stack (cons reg-name (get-contents reg)))
            (advance-pc pc))))
(define (make-restore inst machine stack pc)
    (let ((reg-name (stack-inst-reg-name inst))
          (reg (get-register machine reg-name)))
        (lambda ()
            (set-contents! reg (cons reg-name (pop stack)))
            (advance-pc pc))))
;5.12
;大工程，不想写
;5.13
(define (lookup-register name)
    (let ((val (assoc name register-table)))
        (if val
            (cadr val)
            (begin (allocate-register name)
                   (lookup-register name)))))
;5.14