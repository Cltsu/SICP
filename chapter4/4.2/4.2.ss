(define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp env))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((let? exp) (eval (let-combination exp) env));
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply-moto (actual-value (operator exp) env)
                       (operands exp)
                       env))
          (else
           (error "unkown expression type -- EVAL" exp))))
(define (apply-moto procedure arguments env)
    (cond ((primitive-procedure? procedure);primitive过程是直接从下层scheme拿来的，无法被改为非严格形式
            (apply-primitive-procedure 
                procedure 
                (list-of-arg-values arguments env)));changed
          ((compound-procedure? procedure)
            (eval-sequence
                (procedure-body procedure)
                (extend-environment
                    (procedure-parameters procedure)
                    (list-of-delayed-args arguments env);changed
                    (procedure-environment procedure))))
          (else
            (error "unkown procedure type -- APPLY" procedure))))
(define (actual-value exp env)
    (force-it (eval exp env)))
(define (list-of-arg-values exps env)
    (if (no-operands? exps)
        '()
        (cons (actual-value (first-operand exps) env)
              (list-of-arg-values (rest-operands exps)
                                  env))))
(define (list-of-delayed-args exps env)
    (if (no-operands? exps)
        '()
        (cons (delay-it (first-operand exps) env)
              (list-of-delayed-args (rest-operands exps)
                                    env))))
; (define (force-it obj)
;     (if (thunk? obj)
;         (actual-value (thunk-exp obj) (thunk-env obj))
;         obj)) 
(define (delay-it exp env)
    (list 'thunk exp env))
(define (thunk? obj)
    (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))
(define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
(define (force-it obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                            (thunk-exp obj)
                            (thunk-env obj))))
                (set-car! obj 'evaluated-thunk)
                (set-car! (cdr obj) result)
                (set-cdr! (cdr obj) '())
                result))
          ((evaluated-thunk? obj)
            (thunk-value obj))
          (else obj)))
(define (eval-if exp env)
    (if (true? (actual-value (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))
(define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (actual-value (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
(define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    'ok)
(define (eval-definition exp env)
    (define-variable! (definition-variable exp)
                      (eval (definition-value exp) env)
                      env)
    'ok)
(define (list-of-values exps env)
    (if (no-operands? exps)
        '()
        (cons (eval (first-operand exps) env)
              (list-of-values (rest-operands exps) env))))
(define (self-evaluating? exp)
    (cond ((number? exp) #t)
          ((string? exp) #t)
          (else #f)))
(define (variable? exp) (symbol? exp))
(define (quoted? exp)
    (tagged-list? exp 'quote))
(define (text-of-quotation exp ) (cadr exp))

; (define (text-of-quotation exp env)
;     (let ((content (cadr exp)))
;         (if (pair? content)
;             (eval (make-list content) env)
;             content)))
; (define (make-list l)
;     (display 1)
;     (if (null? l)
;         '()
;         (begin 
;         (list 'cons (list 'quote (car l))
;               (make-list (cdr l)))))
;         )
(define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))
;assignment
(define (assignment? exp)
    (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
;definition
(define (definition? exp)
    (tagged-list? exp 'define))
(define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))
(define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))
;lambda
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))
;if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        '#f))
(define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))
;begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
;application
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
;cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
    (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
    (if (null? clauses)
        '#f
        (let ((first (car clauses))
              (rest (cdr clauses)))
            (if (cond-else-clause? first)
                (if (null? rest)
                    (sequence->exp (cond-actions first))
                    (error "ELSE clause isn't last -- COND->IF" rest))
                (make-if (cond-predicate first)
                         (sequence->exp (cond-actions first))
                         (expand-clauses rest))))))
;谓词检测
(define (true? x) (not (eq? x '#f)))
(define (false? x) (eq? x '#f))
;过程的表示
(define (make-procedure parameters body env)
    (list 'procedure parameters body env))
(define (compound-procedure? p)
    (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
;环境 作为frame的表
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
;frame 表示一个单独的环境
(define (make-frame variable values)
    (cons variable values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))
(define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (error "can't match vals and vars" vars vals)))
(define (lookup-variable-value var env)
    (define (env-loop env)
        (define (scan vars vals)
            (cond ((null? vars) 
                   (env-loop (enclosing-environment env)))
                  ((eq? var (car vars))
                   (car vals))
                  (else (scan (cdr vars) (cdr vals)))))
        (if (eq? env the-empty-environment)
            (error "can't find var" var)
            (let ((frame (first-frame env)))
                (scan (frame-variables frame)
                      (frame-values frame)))))
    (env-loop env))
(define (set-variable-value! var val env)
    (define (env-loop env)
        (define (scan vars vals)
            (cond ((null? vars)
                   (env-loop (enclosing-environment env)))
                  ((eq? var (car vars))
                   (set-car! vals val))
                  (else (scan (cdr vars) (cdr vals)))))
        (if (eq? env the-empty-environment)
            (error "unbound var" var)
            (let ((frame (first-frame env)))
                (scan (frame-variables frame)
                      (frame-values frame)))))
    (env-loop env))
(define (define-variable! var val env)
    (let ((frame (first-frame env)))
        (define (scan vars vals)
            (cond ((null? vars)
                   (add-binding-to-frame! var val frame))
                  ((eq? var (car vars))
                   (set-car! vals val))
                  (else (scan (cdr vars) (cdr vals)))))
        (scan (frame-variables frame)
              (frame-values frame))))
;primitive过程
(define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
(define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cons cons)
          (list 'null? null?)
          (list '+ +)
          (list '= =)
          (list '* *)
          (list 'null? null?)
          (list '() '())
          ))
(define (primitive-procedure-names)
    (map car primitive-procedures))
(define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
         primitive-procedures))
(define (apply-primitive-procedure proc args)
    (apply
        (primitive-implementation proc) args))
(define input-prompt "L-Eval input:")
(define output-prompt "L-Eval output:")
(define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
        (let ((output (actual-value input the-global-environment)))
            (announce-output output-prompt)
            (user-print output)))
    (driver-loop))
(define (prompt-for-input string)
    (newline) (newline) (display string) (newline))
(define (announce-output string)
    (newline) (display string) (newline))
(define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)))
        (display object)))
;全局环境
(define (setup-environment)
    (let ((initial-env
            (extend-environment (primitive-procedure-names)
                                (primitive-procedure-objects)
                                the-empty-environment)))
        (define-variable! '#t #t initial-env)
        (define-variable! '#f #f initial-env)
        initial-env))
(define the-global-environment (setup-environment))
;let
(define (let? exp) (tagged-list? exp 'let))
(define (let-defn exp) (cadr exp))
(define (let-body exp) (cddr exp))
(define (let-combination exp)
    (let ((defn (let-defn exp))
          (body (let-body exp)))
        (let ((vars (map car defn))
              (exps (map cadr defn)))
            (cons (make-lambda vars body)
                  exps))))





;4.25
;死循环
;4.26
;如果将unless实现为if的派生式，它和if就没有任何区别
;派生式的实现也只需要一个unless->if
;4.27
;1 定义w的时候调用了一次id
;10 w为('thunk (id 10) env)
;2
;4.28
;(define (id f) f)
;((id +) 1 2)
;(id +)会返回('thunk + env),不能作为一个运算符
;所以应该force-it，得到('primitive +)
;4.29
;2
;4.30
;a)因为是list表中的元素57 321 88不是过程，不会被封装为thunk，
;b)
;改之前：p1:(1 2)  p2:1
;改之后：p1:(1 2)  p2:(1 2)
;c)变为actual-value就等于是加一层force-it，a中的list本来就不是thunk，有无force-it没有区别
;d)序列求值显然就是为副作用而生的，但是我认为副作用和lazy有不可调和的矛盾，
;优雅的方式应该是像haskell。所以我的建议是在使用lazy的时候尽量避免序列求值。如果一定要用，我倾向于eval而非actual-value.
;4.31
;看起来就好难
;4.32
;本节的lazy表：(cdr ones):(compound-procedure (m) ((m x y)))
;3.5的流:(stream-cdr ones):1
;4.33
;4.34
 (define prev-eval eval) 
  
 (define (eval expr env) 
     (if (quoted? expr) 
         (text-of-quotation expr env) 
         (prev-eval expr env))) 
  
 (define (quoted? expr) (tagged-list? expr 'quote)) 
  
 (define (text-of-quotation expr env)  
         (let ((text (cadr expr))) 
                 (if (pair? text) 
                         (eval (idd text) env) 
                         text)))

(define (idd a) (display (car a)) a)
;  (define (make-list expr) 
;          (if (null? expr) 
;                  (list 'quote '()) 
;                  (list 'cons 
;                            (list 'quote (car expr)) 
;                            (make-list (cdr expr))))) 
(driver-loop)
; (define (cons x y)
;     (lambda (m) (m x y)))
; (define (car z)
;     (z (lambda (p q) p)))
; (define (cdr z)
;     (z (lambda (p q) q)))


